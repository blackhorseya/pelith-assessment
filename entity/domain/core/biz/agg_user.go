package biz

import (
	"errors"
	"strconv"

	"github.com/blackhorseya/pelith-assessment/entity/domain/core/model"
	"github.com/blackhorseya/pelith-assessment/pkg/contextx"
	"go.uber.org/zap"
)

// User is an aggregate root that represents the user.
type User struct {
	model.User

	Tasks        []*Task         `json:"tasks,omitempty"`
	Rewards      []*Reward       `json:"rewards,omitempty"`
	Transactions TransactionList `json:"transactions,omitempty"`

	totalSwapAmount map[string]float64
}

// NewUser creates a new User aggregate.
func NewUser(address string) (*User, error) {
	if address == "" {
		return nil, errors.New("address cannot be empty")
	}

	return &User{
		User: model.User{
			Id:           "", // id is generated by the repository
			Address:      address,
			TaskProgress: make(map[string]int64),
		},
		totalSwapAmount: make(map[string]float64),
	}, nil
}

// OnSwapExecuted is called when a swap transaction is executed.
func (x *User) OnSwapExecuted(ctx contextx.Contextx, tx *Transaction) error {
	x.Transactions = append(x.Transactions, tx)

	// Update the user's total swap amount
	fromAmount, err := strconv.ParseFloat(tx.SwapDetail.FromTokenAmount, 64)
	if err != nil {
		ctx.Error("failed to parse from amount", zap.Error(err))
		return err
	}
	x.totalSwapAmount[tx.SwapDetail.FromTokenAddress] += fromAmount

	toAmount, err := strconv.ParseFloat(tx.SwapDetail.ToTokenAmount, 64)
	if err != nil {
		ctx.Error("failed to parse to amount", zap.Error(err))
		return err
	}
	x.totalSwapAmount[tx.SwapDetail.ToTokenAddress] += toAmount

	// Update the user's task progress
	for _, task := range x.Tasks {
		totalAmount := x.totalSwapAmount[task.Criteria.PoolId]
		if task.Type == model.TaskType_TASK_TYPE_ONBOARDING {
			if totalAmount >= task.Criteria.MinTransactionAmount {
				task.Progress = 100
			} else {
				task.Progress = int((totalAmount / task.Criteria.MinTransactionAmount) * 100)
			}
		}
	}

	return nil
}
